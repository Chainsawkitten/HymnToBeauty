#pragma once

#include "Buffer.hpp"
#include "VertexDescription.hpp"
#include "GeometryBinding.hpp"
#include "RenderPass.hpp"
#include "Shader.hpp"
#include "Texture.hpp"
#include "GraphicsPipeline.hpp"

#include <glm/glm.hpp>
#include <initializer_list>
#include <vector>

struct ShaderSource;

namespace Video {

class CommandBuffer;
class ShaderProgram;
class Texture;

/// Low level renderer abstracting the underlaying graphics API (OpenGL or Vulkan).
class LowLevelRenderer {
  public:
    /// Create a new low-level renderer.
    LowLevelRenderer() {}

    /// Destructor.
    virtual ~LowLevelRenderer() {}

    /// Create a command buffer.
    /**
     * @return The created command buffer.
     */
    virtual CommandBuffer* CreateCommandBuffer() = 0;

    /// Begin a new frame.
    virtual void BeginFrame() = 0;

    /// Submit a command buffer for execution.
    /**
     * @param commandBuffer The command buffer to submit.
     */
    virtual void Submit(CommandBuffer* commandBuffer) = 0;

    /// Present the rendered image to the swap chain.
    virtual void Present() = 0;

    /// Create a GPU buffer.
    /**
     * @param bufferUsage How the buffer will be used.
     * @param size The size of the buffer in bytes.
     * @param data Data to upload to the buffer. Can be nullptr if no data should be uploaded.
     *
     * @return The created buffer.
     */
    virtual Buffer* CreateBuffer(Buffer::BufferUsage bufferUsage, unsigned int size, const void* data = nullptr) = 0;

    /// Create a vertex description.
    /**
     * @param attributeCount The number of vertex attributes.
     * @param attributes The array of attributes.
     * @param indexBuffer Whether to use an index buffer.
     *
     * @return The created vertex description.
     */
    virtual VertexDescription* CreateVertexDescription(unsigned int attributeCount, const VertexDescription::Attribute* attributes, bool indexBuffer = false) = 0;

    /// Create a geometry binding.
    /**
     * @param vertexDescriptiopn Description of the attributes in the vertex buffer.
     * @param vertexBuffer Buffer containing the vertex data.
     * @param indexType The type of values in the index buffer.
     * @param indexBuffer Index buffer.
     *
     * @return The created geometry binding.
     */
    virtual GeometryBinding* CreateGeometryBinding(const VertexDescription* vertexDescription, const Buffer* vertexBuffer, GeometryBinding::IndexType indexType = GeometryBinding::IndexType::NONE, const Buffer* indexBuffer = nullptr) = 0;

    /// Create a shader.
    /**
     * @param shaderSource The source of the shader, generated by the shader processor.
     * @param type The type of shader to create.
     *
     * @return The created shader.
     */
    virtual Shader* CreateShader(const ShaderSource& shaderSource, Shader::Type type) = 0;

    /// Create a shader program.
    /**
     * Link together shaders into a shader program that can be run on the GPU.
     *
     * Sample:
     * \code{.cpp}
     * Shader* vertexShader = lowLevelRenderer->CreateShader(vertexSource, Shader::Type::VERTEX_SHADER);
     * Shader* fragmentShader = lowLevelRenderer->CreateShader(fragmentSource, Shader::Type::FRAGMENT_SHADER);
     * ShaderProgram* shaderProgram = lowLevelRenderer->CreateShaderProgram({ vertexShader, fragmentShader });
     * \endcode
     *
     * @param shaders List of shaders to link together.
     *
     * @return The created shader program.
     */
    virtual ShaderProgram* CreateShaderProgram(std::initializer_list<const Shader*> shaders) = 0;

    /// Create a texture.
    /**
     * @param size The size of the texture, in pixels.
     * @param type The type of texture to create.
     * @param format The format of the texture.
     * @param components The number of components in the texture, 0 if no texture data is supplied.
     * @param data The texture data to upload, or nullptr.
     */
    virtual Texture* CreateTexture(const glm::uvec2 size, Texture::Type type, Texture::Format format, int components = 0, unsigned char* data = nullptr) = 0;

    /// Create a render pass.
    /**
     * @param colorAttachment The color attachment to draw to.
     * @param colorLoadOperation What to do with the previous contents of the color attachment.
     * @param depthAttachment The depth attachment to draw to.
     * @param depthLoadOperation What to do with the previous contents of the depth attachment.
     */
    virtual RenderPass* CreateRenderPass(Texture* colorAttachment, RenderPass::LoadOperation colorLoadOperation = RenderPass::LoadOperation::CLEAR, Texture* depthAttachment = nullptr, RenderPass::LoadOperation depthLoadOperation = RenderPass::LoadOperation::CLEAR) = 0;

    /// Create a graphics pipeline.
    /**
     * @param shaderProgram The shader program to use.
     * @param configuration The configuration of the pipeline.
     * @param vertexDescription The description of the vertex input to the pipeline.
     */
    virtual GraphicsPipeline* CreateGraphicsPipeline(const ShaderProgram* shaderProgram, const GraphicsPipeline::Configuration& configuration, const VertexDescription* vertexDescription = nullptr) = 0;

    /// Wait for all rendering to finish.
    virtual void Wait() = 0;

    /// Read a render pass' color image.
    /**
     * @param renderPass The render pass to read.
     *
     * @return The color image as a char-array.
     */
    virtual char* ReadImage(RenderPass* renderPass) = 0;

  private:
    LowLevelRenderer(const LowLevelRenderer& other) = delete;
};

} // namespace Video
