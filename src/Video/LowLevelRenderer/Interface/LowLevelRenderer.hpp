#pragma once

#include "Buffer.hpp"
#include "VertexDescription.hpp"
#include "GeometryBinding.hpp"
#include "RenderPass.hpp"
#include "Shader.hpp"
#include "Texture.hpp"
#include "Sampler.hpp"
#include "GraphicsPipeline.hpp"

#include <glm/glm.hpp>
#include <initializer_list>
#include <vector>
#include <Utility/Profiling/Event.hpp>

struct ShaderSource;

namespace Video {

class CommandBuffer;
class ShaderProgram;
class Texture;
class ComputePipeline;

/// Low level renderer abstracting the underlaying graphics API (OpenGL or Vulkan).
class LowLevelRenderer {
  public:
    /// Optional features.
    struct OptionalFeatures {
        /// Whether non-solid fill modes (point and line) are supported.
        bool fillModeNonSolid;

        /// Whether wide lines are supported.
        bool wideLines;

        /// Whether timestamps are supported.
        bool timestamps;

        /// Whether conservative rasterization is supported.
        bool conservativeRasterization;

        /// Bitmask of the number of MSAA samples supported for attachmentless rendering.
        uint32_t attachmentlessMsaaSamples;
    };

    /// Create a new low-level renderer.
    LowLevelRenderer() {}

    /// Destructor.
    virtual ~LowLevelRenderer() {}

    /// Create a command buffer.
    /**
     * @return The created command buffer.
     */
    virtual CommandBuffer* CreateCommandBuffer() = 0;

    /// Begin a new frame.
    virtual void BeginFrame() = 0;

    /// Submit a command buffer for execution.
    /**
     * @param commandBuffer The command buffer to submit.
     */
    virtual void Submit(CommandBuffer* commandBuffer) = 0;

    /// Present the rendered image to the swap chain.
    virtual void Present() = 0;

    /// Create a GPU buffer.
    /**
     * @param bufferUsage How the buffer will be used.
     * @param size The size of the buffer in bytes.
     * @param data Data to upload to the buffer. Can be nullptr if no data should be uploaded.
     *
     * @return The created buffer.
     */
    virtual Buffer* CreateBuffer(Buffer::BufferUsage bufferUsage, unsigned int size, const void* data = nullptr) = 0;

    /// Create a temporary GPU buffer.
    /**
     * The returned buffer's lifetime is controlled by the rendered and should not be deleted.
     *
     * @param bufferUsage How the buffer will be used.
     * @param size The size of the buffer in bytes.
     * @param data Data to upload to the buffer. Can be nullptr if no data should be uploaded.
     *
     * @return The created buffer.
     */
    virtual Buffer* CreateTemporaryBuffer(Buffer::BufferUsage bufferUsage, unsigned int size, const void* data = nullptr) = 0;

    /// Create a vertex description.
    /**
     * @param attributeCount The number of vertex attributes.
     * @param attributes The array of attributes.
     * @param indexBuffer Whether to use an index buffer.
     *
     * @return The created vertex description.
     */
    virtual VertexDescription* CreateVertexDescription(unsigned int attributeCount, const VertexDescription::Attribute* attributes, bool indexBuffer = false) = 0;

    /// Create a geometry binding.
    /**
     * @param vertexDescription Description of the attributes in the vertex buffer.
     * @param vertexBuffer Buffer containing the vertex data.
     * @param indexType The type of values in the index buffer.
     * @param indexBuffer Index buffer.
     *
     * @return The created geometry binding.
     */
    virtual GeometryBinding* CreateGeometryBinding(const VertexDescription* vertexDescription, Buffer* vertexBuffer, GeometryBinding::IndexType indexType = GeometryBinding::IndexType::NONE, const Buffer* indexBuffer = nullptr) = 0;

    /// Create a shader.
    /**
     * @param shaderSource The source of the shader, generated by the shader processor.
     * @param type The type of shader to create.
     *
     * @return The created shader.
     */
    virtual Shader* CreateShader(const ShaderSource& shaderSource, Shader::Type type) = 0;

    /// Create a shader program.
    /**
     * Link together shaders into a shader program that can be run on the GPU.
     *
     * Sample:
     * \code{.cpp}
     * Shader* vertexShader = lowLevelRenderer->CreateShader(vertexSource, Shader::Type::VERTEX_SHADER);
     * Shader* fragmentShader = lowLevelRenderer->CreateShader(fragmentSource, Shader::Type::FRAGMENT_SHADER);
     * ShaderProgram* shaderProgram = lowLevelRenderer->CreateShaderProgram({ vertexShader, fragmentShader });
     * \endcode
     *
     * @param shaders List of shaders to link together.
     *
     * @return The created shader program.
     */
    virtual ShaderProgram* CreateShaderProgram(std::initializer_list<const Shader*> shaders) = 0;

    /// Create a texture.
    /**
     * @param size The size of the texture, in pixels.
     * @param format The format of the texture.
     * @param components The number of components in the texture, 0 if no texture data is supplied.
     * @param data The texture data to upload, or nullptr.
     * 
     * @return The created texture.
     */
    virtual Texture* CreateTexture(const glm::uvec2 size, Texture::Format format, int components, unsigned char* data) = 0;

    /// Get a sampler.
    /**
     * @param filter The interpolation to apply.
     * @param clamping How to handle sampling outside the texture dimensions.
     * 
     * @return The requested sampler.
     */
    virtual const Sampler* GetSampler(Sampler::Filter filter, Sampler::Clamping clamping) const = 0;

    /// Create a render target.
    /**
     * @param size The size of the texture, in pixels.
     * @param format The format of the texture.
     * 
     * @return The created texture.
     */
    virtual Texture* CreateRenderTarget(const glm::uvec2& size, Texture::Format format) = 0;

    /// Free a render target.
    /**
     * @param renderTarget The render target to free.
     */
    virtual void FreeRenderTarget(Texture* renderTarget) = 0;

    /// Create a graphics pipeline.
    /**
     * @param shaderProgram The shader program to use.
     * @param configuration The configuration of the pipeline.
     * @param vertexDescription The description of the vertex input to the pipeline.
     * 
     * @return The created graphics pipeline.
     */
    virtual GraphicsPipeline* CreateGraphicsPipeline(const ShaderProgram* shaderProgram, const GraphicsPipeline::Configuration& configuration, const VertexDescription* vertexDescription = nullptr) = 0;

    /// Create a compute pipeline.
    /**
     * @param shaderProgram The shader program to use.
     * 
     * @return The created compute pipeline.
     */
    virtual ComputePipeline* CreateComputePipeline(const ShaderProgram* shaderProgram) = 0;

    /// Wait for all rendering to finish.
    virtual void Wait() = 0;

    /// Read a render texture color image.
    /**
     * @param texture The texture to read.
     *
     * @return The color image as a char-array.
     */
    virtual unsigned char* ReadImage(Texture* texture) = 0;

    /// Set whether to profile.
    /**
     * @param profiling Whether to profile.
     */
    void SetProfiling(bool profiling) {
        this->profiling = profiling;
    }

    /// Get whether profiling is active.
    /**
     * @return Whether profiling is active.
     */
    bool IsProfiling() const {
        return profiling;
    }

    /// Get profiling timeline.
    /**
     * @return A list of events that have occurred since the last time fetching the timeline.
     */
    virtual const std::vector<Profiling::Event>& GetTimeline() const = 0;

    /// Get which optional features are supported.
    /**
     * @return Which optional features are supported.
     */
    virtual const OptionalFeatures& GetOptionalFeatures() const = 0;

  private:
    LowLevelRenderer(const LowLevelRenderer& other) = delete;

    bool profiling = false;
};

} // namespace Video
